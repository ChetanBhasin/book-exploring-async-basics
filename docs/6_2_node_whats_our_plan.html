<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>What's our plan - Investigating Async Basics - Implementing the Node.js Eventloop in Rust</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="1_concurrent_vs_parallel.html"><strong aria-hidden="true">1.</strong> Concurrent vs Parallel</a></li><li><a href="2_async_history.html"><strong aria-hidden="true">2.</strong> Async history</a></li><li><a href="3_0_the_operating_system.html"><strong aria-hidden="true">3.</strong> The Operating System and CPU</a></li><li><ol class="section"><li><a href="3_1_communicating_with_the_os.html"><strong aria-hidden="true">3.1.</strong> Communicating with the OS</a></li><li><a href="3_1_1_cross_platform_abstractions.html"><strong aria-hidden="true">3.2.</strong> Writing Cross Platform Abstractions</a></li><li><a href="3_2_the_cpu_and_the_os.html"><strong aria-hidden="true">3.3.</strong> The CPU and the OS</a></li></ol></li><li><a href="4_interrupts_firmware_io.html"><strong aria-hidden="true">4.</strong> Interrupts, Firmware and I/O</a></li><li><a href="5_strategies_for_handling_io.html"><strong aria-hidden="true">5.</strong> Strategies for handling I/O</a></li><li><a href="6_0_implementing_the_node_eventloop.html"><strong aria-hidden="true">6.</strong> Implementing the Node Eventloop</a></li><li><ol class="section"><li><a href="6_1_what_is_node.html"><strong aria-hidden="true">6.1.</strong> What is Node?</a></li><li><a href="6_2_node_whats_our_plan.html" class="active"><strong aria-hidden="true">6.2.</strong> What's our plan</a></li><li><a href="6_3_node_the_main_loop.html"><strong aria-hidden="true">6.3.</strong> The main loop</a></li><li><a href="6_4_implementing_the_runtime.html"><strong aria-hidden="true">6.4.</strong> Implementing the Runtime</a></li><li><a href="6_5_node_the_threadpool.html"><strong aria-hidden="true">6.5.</strong> The threadpool</a></li><li><a href="6_6_node_the_io_eventqueue.html"><strong aria-hidden="true">6.6.</strong> The I/O eventqueue</a></li><li><a href="6_7_shortcuts_and_improvements.html"><strong aria-hidden="true">6.7.</strong> Shortcuts and improvements</a></li><li><a href="6_8_node_final_code.html"><strong aria-hidden="true">6.8.</strong> Final code</a></li></ol></li><li><a href="conclusion.html">Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Investigating Async Basics - Implementing the Node.js Eventloop in Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#whats-our-plan" id="whats-our-plan">What's our plan</a></h1>
<p>For our plan to work we need a runtime to run our &quot;javascript&quot;.</p>
<p>Let's first start with our &quot;javascript&quot;:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Think of this function as the javascript program you have written
fn javascript() {
    print(&quot;First call to read test.txt&quot;);
    Fs::read(&quot;test.txt&quot;, |result| {
        let text = result.into_string().unwrap();
        let len = text.len();
        print(format!(&quot;First count: {} characters.&quot;, len));

        print(r#&quot;I want to create a &quot;magic&quot; number based on the text.&quot;#);
        Crypto::encrypt(text.len(), |result| {
            let n = result.into_int().unwrap();
            print(format!(r#&quot;&quot;Encrypted&quot; number is: {}&quot;#, n));
        })
    });


    print(&quot;Registering immediate timeout 1&quot;);
    set_timeout(0, |_res| {
        print(&quot;Immediate1 timed out&quot;);
    });
    print(&quot;Registering immediate timeout 2&quot;);
    set_timeout(0, |_res| {
        print(&quot;Immediate2 timed out&quot;);
    });
    print(&quot;Registering immediate timeout 3&quot;);
    set_timeout(0, |_res| {
        print(&quot;Immediate3 timed out&quot;);
    });
    // let's read the file again and display the text
    print(&quot;Second call to read test.txt&quot;);
    Fs::read(&quot;test.txt&quot;, |result| {
        let text = result.into_string().unwrap();
        let len = text.len();
        print(format!(&quot;Second count: {} characters.&quot;, len));

        // aaand one more time but not in parallell.
        print(&quot;Third call to read test.txt&quot;);
        Fs::read(&quot;test.txt&quot;, |result| {
            let text = result.into_string().unwrap();
            print_content(&amp;text, &quot;file read&quot;);
        });
    });

    print(&quot;Registering a 3000 and a 500 ms timeout&quot;);
    set_timeout(3000, |_res| {
        print(&quot;3000ms timer timed out&quot;);
        set_timeout(500, |_res| {
            print(&quot;500ms timer(nested) timed out&quot;);
        });
    });

    print(&quot;Registering a 1000 ms timeout&quot;);
    set_timeout(1000, |_res| {
        print(&quot;SETTIMEOUT&quot;);
    });

    // `http_get_slow` let's us define a latency we want to simulate
    print(&quot;Registering http get request to google.com&quot;);
    Io::http_get_slow(&quot;http//www.google.com&quot;, 2000, |result| {
        let result = result.into_string().unwrap();
        print_content(result.trim(), &quot;web call&quot;);
    });
}

fn print(t: impl std::fmt::Display) {
    println!(&quot;Thread: {}\t {}&quot;, current(), t);
}

fn print_content(t: impl std::fmt::Display, descr: &amp;str) {
    println!(
        &quot;\n===== THREAD {} START CONTENT - {} =====&quot;,
        current(),
        descr.to_uppercase()
    );
    println!(&quot;{}&quot;, t);
    println!(&quot;===== END CONTENT =====\n&quot;);
}
#}</code></pre></pre>
<p>Next, let's feed this code into our runtime:</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut rt = Runtime::new();
    rt.run(javascript);
}
</code></pre></pre>
<p>Now before we go on to implement our runtime we'll need some helper functions:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn print(t: impl std::fmt::Display) {
    println!(&quot;Thread: {}\t {}&quot;, current(), t);
}

fn print_content(t: impl std::fmt::Display, descr: &amp;str) {
    println!(
        &quot;\n===== THREAD {} START CONTENT - {} =====&quot;,
        current(),
        descr.to_uppercase()
    );
    println!(&quot;{}&quot;, t);
    println!(&quot;===== END CONTENT =====\n&quot;);
}

fn current() -&gt; String {
    thread::current().name().unwrap().to_string()
}

#}</code></pre></pre>
<p>Here we define three functions:</p>
<p><code>print</code> which prints out a message that first tells us what thread the message is beeing outputted from, and then a message we provide:</p>
<p><code>print_content</code> does the same as <code>print</code> but is a way for us to print out more than a message in a nice way.</p>
<p><code>current</code> is just a shortcut for us to get the name of the current thread. Since we want to track what's happening where we're going to need to print out what thread is issuing what output so this will avoid cluttering up our code too much along the way.</p>
<p>Next we pull in some modules from the standard library and we refer to an external library called <code>minimio</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::collections::{BTreeMap, HashMap};
use std::fmt;
use std::fs;
use std::io::{Read, Write};
use std::sync::mpsc::{channel, Receiver, Sender};
use std::thread::{self, JoinHandle};
use std::time::{Duration, Instant};

use minimio;
#}</code></pre></pre>
<h2><a class="header" href="#minimio" id="minimio">Minimio</a></h2>
<p>Minimio is a cross platform epoll/kqueue/IOCP based event loop that we will cover in the next book. I originally included it here but implementing that for three arcitectures is pretty interesting and needed more space than would fit in this book.</p>
<p>Most modern I/O eventloops uses a cross platform library like this. In Rust we have <a href="https://github.com/tokio-rs/mio"><code>mio</code></a>, Node uses <a href="https://github.com/libuv/libuv"><code>libuv</code></a> and there are several more. However, creating a cross platform general eventloop is pretty challenging since Windows and Unix has different ways of handeling events. We'll talk much more about this in the next book but let's just make a note of it here.</p>
<p>Let's briefly cover the how this works and why we need this in Node:</p>
<h3><a class="header" href="#epoll" id="epoll">Epoll</a></h3>
<p><code>Epoll</code> is the Linux way of implementing an event queue. In terms of functionality it has a lot of common with <code>Kqueue</code>. On a high level these abstractions provide us with this functionality:</p>
<ol>
<li>A handle to an event queue</li>
<li>A way for us to register interest for events on a file descriptor and place it in this queue</li>
<li>A way for us to wait for this event to occur by letting the OS suspend our thread and wake us up when event is ready</li>
</ol>
<h3><a class="header" href="#kqueue" id="kqueue">Kqueue</a></h3>
<p><code>Kqueue</code> is the Macos way of implementing an event queue, well, actually it's the BSD way of doint this that Macos uses. In terms of high level functionality it's similar to <code>Epoll</code>.</p>
<p>The differences are in how you interact with the queues and there are some differences in functionality but for the normal use case they are similar enough.</p>
<h3><a class="header" href="#iocp" id="iocp">IOCP</a></h3>
<p><code>IOCP</code> or Input Output Completion Ports is the way Windows handles this type of event queue. This type of queue works differently from <code>epoll</code> and <code>kqueue</code>. The biggest difference in terms of functionality is that <code>epoll</code> and <code>kqueue</code> lets you know when an event is ready (i.e. some data is ready to be read). We call this form of model a <code>readiness based</code> model.</p>
<p>Windows on the other hand uses a <code>completion based</code> model. This means it will let you know when an event has <code>Completed</code>. Now this might sound like a minor difference but it's not, especially when you want to write a library.</p>
<p>The major difficulty is that you either need to get <code>epoll</code> or <code>kqueue</code> to behave like they're <code>completion based</code> or you'll have to try to get Windows to behave in a <code>readiness based</code> manner. The latter is the way <code>wepoll</code> and <code>mio</code> does it but this change is very recent and uses a few undocumented parts of the Windows API.</p>
<h2><a class="header" href="#important-things-to-note-before-reading-further" id="important-things-to-note-before-reading-further">Important things to note before reading further</a></h2>
<p>We have to explain some things right here to prepare you for the rest.</p>
<p>We are using a callback based model, as is Node. </p>
<p>Our code here is mostly calling functions that register an event, and stores a
callback to be run when the event is ready.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
set_timeout(0, |_res| {
    print(&quot;Immediate1 timed out&quot;);
});
#}</code></pre></pre>
<p>What happens here is that we register interest in a <code>timeout</code> event. And we register
the callback <code>|_res| { print(&quot;Immediate1 timed out&quot;); }</code>. Now the parameter <code>_res</code> is
an argument that is passed in to our callback. In javascript it would be left out, but
since we use a typed language we have created a type called <code>Js</code>.</p>
<p><code>Js</code> is an enum that represents Javascript types. In the case of <code>set_timeout</code> it's
<code>Js::undefined</code>. In the case of <code>Fs::read</code> it's an <code>Js::String</code> and so on.</p>
<p>Now this callback is given an <strong>unique Id</strong> and is stored until the event occurs and
we invoke the callback and pass in any arguments we might have. In the case of <code>Fs::read</code>
that would be the text representation of the file we read.</p>
<h3><a class="header" href="#nodes-eventloops" id="nodes-eventloops">Nodes eventloop(s)</a></h3>
<p>Node internally divides it's real work into two categories:</p>
<h4><a class="header" href="#io-bound-tasks" id="io-bound-tasks">I/O bound tasks</a></h4>
<p>Are handleded by the cross platform epoll/kqueue/IOCP event queue implemented in <code>libuv</code> and in our case <code>minimio</code>.</p>
<h4><a class="header" href="#cpu-bound-tasks" id="cpu-bound-tasks">CPU bound tasks</a></h4>
<p>Are handeled by an threadpool. The default size of this threadpool is 4 threads, but that can be configured by the Node runtime.</p>
<p>I/O tasks which can't be handled by the cross platform eventqueue is also handled here which is the case with file reads which we use in our example.</p>
<p>Most C++ extensions for Node uses this threadpool to perform their work and that is one of many reasons they are used for CPU heavy tasks.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="6_1_what_is_node.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="6_3_node_the_main_loop.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="6_1_what_is_node.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="6_3_node_the_main_loop.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
