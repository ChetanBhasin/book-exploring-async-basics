<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The main loop - Investigating Async Basics - Implementing the Node.js Eventloop in Rust</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="1_concurrent_vs_parallel.html"><strong aria-hidden="true">1.</strong> Concurrent vs Parallel</a></li><li><a href="2_async_history.html"><strong aria-hidden="true">2.</strong> Async history</a></li><li><a href="3_0_the_operating_system.html"><strong aria-hidden="true">3.</strong> The Operating System and CPU</a></li><li><ol class="section"><li><a href="3_1_communicating_with_the_os.html"><strong aria-hidden="true">3.1.</strong> Communicating with the OS</a></li><li><a href="3_1_1_cross_platform_abstractions.html"><strong aria-hidden="true">3.2.</strong> Writing Cross Platform Abstractions</a></li><li><a href="3_2_the_cpu_and_the_os.html"><strong aria-hidden="true">3.3.</strong> The CPU and the OS</a></li></ol></li><li><a href="4_interrupts_firmware_io.html"><strong aria-hidden="true">4.</strong> Interrupts, Firmware and I/O</a></li><li><a href="5_strategies_for_handling_io.html"><strong aria-hidden="true">5.</strong> Strategies for handling I/O</a></li><li><a href="6_0_implementing_the_node_eventloop.html"><strong aria-hidden="true">6.</strong> Implementing the Node Eventloop</a></li><li><ol class="section"><li><a href="6_1_what_is_node.html"><strong aria-hidden="true">6.1.</strong> What is Node?</a></li><li><a href="6_2_node_whats_our_plan.html"><strong aria-hidden="true">6.2.</strong> What's our plan</a></li><li><a href="6_3_node_the_main_loop.html" class="active"><strong aria-hidden="true">6.3.</strong> The main loop</a></li><li><a href="6_4_implementing_the_runtime.html"><strong aria-hidden="true">6.4.</strong> Implementing the Runtime</a></li><li><a href="6_5_node_the_threadpool.html"><strong aria-hidden="true">6.5.</strong> The threadpool</a></li><li><a href="6_6_node_the_io_eventqueue.html"><strong aria-hidden="true">6.6.</strong> The I/O eventqueue</a></li><li><a href="6_7_shortcuts_and_improvements.html"><strong aria-hidden="true">6.7.</strong> Shortcuts and improvements</a></li><li><a href="6_8_node_final_code.html"><strong aria-hidden="true">6.8.</strong> Final code</a></li></ol></li><li><a href="conclusion.html">Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Investigating Async Basics - Implementing the Node.js Eventloop in Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-main-loop" id="the-main-loop">The main loop</a></h1>
<p>Before we implement the eventlopp we need to set up our Runtime so we can save all our state there:</p>
<p>When we're finished, our Runtime struct will look like this: </p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Runtime {
    
}

#}</code></pre></pre>
<p>Don't worry, we'll fill in the fields as we go along but I didn't want you to 
stop now an try to figure out what everything is.</p>
<p>Let's get back on track. And talk a bit about the eventloop, which probably is 
the most interesting part of code in this book since there has been som much
written about it:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Runtime {
    pub fn run(&amp;mut self, f: impl Fn()) {
        let rt_ptr: *mut Runtime = self;
        unsafe { RUNTIME = rt_ptr as usize };

        let mut timers_to_remove = vec![]; // avoid allocating on every loop
        let mut ticks = 0; // just for us priting out

        // First we run our &quot;main&quot; function
        f();

        // ===== EVENT LOOP =====
        while self.pending_events &gt; 0 {
            ticks += 1;

            // ===== 2. TIMERS =====
            self.effectuate_timers(&amp;mut timers_to_remove);

            // NOT PART OF LOOP, JUST FOR US TO SEE WHAT TICK IS EXCECUTING
            if !self.callbacks_to_run.is_empty() {
                print(format!(&quot;===== TICK {} =====&quot;, ticks));
            }

            // ===== 2. CALLBACKS =====
            // Timer callbacks and if for some reason we have postponed callbacks
            // to run on the next tick. Not possible in our implementation though.
            self.run_callbacks();

            // ===== 3. IDLE/PREPARE =====
            // we won't use this

            // ===== 4. POLL =====
            // NB! Timeout! Normally we set these &quot;blocking&quot; polls to time out
            // when we calculate the next timer to expire, we set that as the
            // timeout to our epoll queue. Then we block the loop while waiting
            // for an event to happen or a timeout to expire.
            self.process_epoll_events();
            self.process_threadpool_events();
            self.run_callbacks();

            // ===== 5. CHECK =====
            // an set immidiate function could be added pretty easily but we 
            // won't do that here

            // ===== 6. CLOSE CALLBACKS ======
            // Release resources, we won't do that here, but this is typically
            // where sockets etc are closed.

            // Let the OS have a time slice of our thread so we don't busy loop
            // this could be dynamically set depending on requirements or load.
            thread::park_timeout(std::time::Duration::from_millis(1));
        }
        print(&quot;FINISHED&quot;);
    }
}
#}</code></pre></pre>
<p>I present the full function here to get a overview since this will be what is
running our runtime. As you see I've made several comments where there are steps
that are performed by Node but which we will skip.</p>
<p>I'll step through each step here, and while I do that I will try to point out
where the real Node runtime differs substantially from ours.</p>
<h2><a class="header" href="#initialization" id="initialization">Initialization</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let rt_ptr: *mut Runtime = self;
unsafe { RUNTIME = rt_ptr as usize };
let mut timers_to_remove = vec![]; 
let mut ticks = 0; // just for us priting out

// First we run our &quot;main&quot; function
f();
#}</code></pre></pre>
<p>The first two lines is just a <code>hack</code> we use in our code to make it &quot;look&quot; more
like javascript. Here we take the pointer to <code>self</code> and set it in the global
variable <code>RUNTIME</code>. We could instead pass our <code>runtime</code> around but that wouldn't
be very ergonomic. Another option would be to use <code>lazy_static</code> crate to initlialize
this field in a safer way, but we'd have to explain what <code>lazy_static</code> do to keep
our promise of minimal &quot;magic&quot;. To be honest, we only set this once, and it's set at
the start of of our eventloop and not touched until it's finished so in this case we
could argue it's safe to do it like this.</p>
<p>The variable <code>timers_to_remove</code> is for us to keep track of the timers we've set.
<code>ticks</code> is only a counter for us to keep track of how many times we've looped
to display.</p>
<p>The first thing we do to kick of the code is invoking <code>f()</code>. <code>f</code> will be the
code we wrote in the <code>javascript</code> function in the last chapter. If this is empty
nothing will happen.</p>
<h2><a class="header" href="#starting-the-event-loop" id="starting-the-event-loop">Starting the event loop</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ===== EVENT LOOP =====
while self.pending_events &gt; 0 {
    ticks += 1;
#}</code></pre></pre>
<p>There are two things to note here:</p>
<p><code>self.pending_events</code> isn't in our runtime struct yet so we need to add that. 
This variable keeps track of how many pending events we have, so that when no 
events are left we exit the loop since our eventloop is finished.</p>
<p>So where does these events come from? In our <code>javascript</code> function in the 
previous chapters you probably noticed that we called functions like 
<code>set_timeout</code> and <code>Fs::read</code>. These functions are defined in the Node runtime 
(as they are in ours), and they don't do much except from regestering events. 
So when one of these events are registered this counter is increased.</p>
<p><code>ticks</code> is just increasing a <code>tick</code> in the counter.</p>
<p>So our Runtime struct looks like this now:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Runtime {
    pending_events: usize,
}
#}</code></pre></pre>
<h2><a class="header" href="#1-effectuate-timers" id="1-effectuate-timers">1. Effectuate timers</a></h2>
<p><code>self.effectuate_timers(&amp;mut timers_to_remove);</code></p>
<p>We check here if any timers has expired. I couldn't find a better word for it
than <code>effectuate</code> but it basically mean that if we have timers that are expired
we schedule the callbacks for the expired timers to run at the first call to <code>self.run_callbacks()</code>.</p>
<p>Worth noting here is that timers with a timeout of <code>0</code> will already have timed
out by the time we reach this function.</p>
<h2><a class="header" href="#2-callbacks" id="2-callbacks">2. Callbacks</a></h2>
<p><code>self.run_callbacks();</code></p>
<p>Now we could have ran the callbacks in the timer <code>step</code> but since this is the next
step of our loop we do it here instead.</p>
<blockquote>
<p>This step might seem unnecessary here but in Node it has a function. Some
types of callbacks will be deferred to the <code>next tick</code>, which means that they're
not run immediately, but deferred to this step on the next loop. We won't implement
this functionality here but it's worth noting.</p>
</blockquote>
<h2><a class="header" href="#3-idleprepare" id="3-idleprepare">3. Idle/Prepare</a></h2>
<p>This is a step mostly used by Nodes internals. It's not important for understanding
the big picture here but I included it since it's something you see in Nodes
documentation so you know where we're at in the loop at this point.</p>
<h2><a class="header" href="#4-poll" id="4-poll">4. Poll</a></h2>
<p>This is really where everything happens. I refer to the <code>epoll/kqueue/IOCP</code> 
eventqueue as <code>epoll</code> here just so you know that it's not only <code>epoll</code> we're
waiting for. From now on I will refer to the cross platform event queue as <code>epoll</code>
in the code.</p>
<p>First we check if the OS has reported any events, and if so we schedule the
corresponding callbacks to run.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
self.process_epoll_events();
#}</code></pre></pre>
<p>Next we check if our threadpool has finished any work and if so we schedule their
corresponding callbacks to be run too:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
self.process_threadpool_events();
#}</code></pre></pre>
<p>If our <code>epoll</code> queue or our <code>threadpool</code> registered any callbacks we run them now.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
self.run_callbacks();
#}</code></pre></pre>
<blockquote>
<p>There are some important differences between our implementation and Nodes here.</p>
<p>We only check if any events are registered here and then continue on. This is
suboptimal since if we're wasting cycles by looping when there might be nothing
to do on the next iteration. </p>
<p>Node solves this by calculating the time until the next timeout (in step 1) 
times out. Let's say that the next timer times out in 10 seconds. In node 10 
seconds is then passed as a timeout for the <code>polls</code> in our poll phase so even 
though no event has happened it will wake up again and iterate so it executes 
the next timer when it starts the loop again. As you understand, that means
that the timer will not run at the exact same time as it times out, but it's
potentially much more efficient than what we do here.</p>
</blockquote>
<h2><a class="header" href="#5-check" id="5-check">5. Check</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ===== CHECK =====
// an set immediate function could be added pretty easily but we won't that here
#}</code></pre></pre>
<p>Node implements a check &quot;hook&quot; to the eventloop next. Calls to <code>setImmidiate</code>
execute here. I just include it for for completeness but we won't do anything in this phase.</p>
<h2><a class="header" href="#6-close-callbacks" id="6-close-callbacks">6. Close Callbacks</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ===== CLOSE CALLBACKS ======
// Release resources, we won't do that here, it's just another &quot;hook&quot; for our &quot;extensions&quot;
// to use. We release in every callback instead
#}</code></pre></pre>
<p>I pretty much explain this step in the comments. Typically releasing resources,
like closing sockets, is done here.</p>
<h2><a class="header" href="#shortcuts" id="shortcuts">Shortcuts</a></h2>
<p>I'll mention some obvious shortcuts right here so you are aware of them. There are many &quot;exceptions&quot; that we don't cover in our example. We are focusing on the big picture just so we're on the same page. The <code>process.nextTick</code> function and the <code>setImmediate</code> function are two examples of this. I explained how we did skip the fact that the next timeout will define how long the <code>poll</code> phase will potentially block instead of continue the loop like we do here.</p>
<p>We don't cover the case where a server under heavy load might have too many callbacks to reasonably run in one <code>poll</code> which means that we could starve our I/O resources in the meantime waiting for them to finish, and probably several similar cases that a production
runtime should care about.</p>
<p>As you'll probably notice, implementing a simple version is more than enough work
for us to cover in this book, but hopefully you'll find yourself in pretty good
shape to dig further once we're finished.</p>
<p>If you do want to know more about the Node eventloop I have two talks for you that I find great (and correct) on this subject:</p>
<p>This first one is made held by <a href="https://github.com/piscisaureus">@piscisaureus</a> and is an excellent 15 minute overview:</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/PNa9OMajw9w" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<p>The second one is slightly longer but is also an excellent talk held by <a href="https://github.com/nebrius">Bryan Hughes</a></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/zphcsoSJMvM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="6_2_node_whats_our_plan.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="6_4_implementing_the_runtime.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="6_2_node_whats_our_plan.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="6_4_implementing_the_runtime.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
