<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Communicating with the OS - Investigating Async Basics - Implementing the Node.js Eventloop in Rust</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="1_concurrent_vs_parallel.html"><strong aria-hidden="true">1.</strong> Concurrent vs Parallel</a></li><li><a href="2_async_history.html"><strong aria-hidden="true">2.</strong> Async history</a></li><li><a href="3_0_the_operating_system.html"><strong aria-hidden="true">3.</strong> The Operating System and CPU</a></li><li><ol class="section"><li><a href="3_1_communicating_with_the_os.html" class="active"><strong aria-hidden="true">3.1.</strong> Communicating with the OS</a></li><li><a href="3_2_cross_platform_abstractions.html"><strong aria-hidden="true">3.2.</strong> Writing Cross Platform Abstractions</a></li><li><a href="3_3_the_cpu_and_the_os.html"><strong aria-hidden="true">3.3.</strong> The CPU and the OS</a></li></ol></li><li><a href="4_interrupts_firmware_io.html"><strong aria-hidden="true">4.</strong> Interrupts, Firmware and I/O</a></li><li><a href="5_strategies_for_handling_io.html"><strong aria-hidden="true">5.</strong> Strategies for handling I/O</a></li><li><a href="6_0_implementing_the_node_eventloop.html"><strong aria-hidden="true">6.</strong> Implementing our &quot;Node&quot; Eventloop</a></li><li><ol class="section"><li><a href="6_1_what_is_node.html"><strong aria-hidden="true">6.1.</strong> What is Node?</a></li><li><a href="6_2_whats_our_plan.html"><strong aria-hidden="true">6.2.</strong> What's our plan</a></li><li><a href="6_3_epoll_kqueue_iocp.html"><strong aria-hidden="true">6.3.</strong> Epoll, Kqueue and IOCP</a></li></ol></li><li><a href="7_0_the_runtime.html"><strong aria-hidden="true">7.</strong> The runtime</a></li><li><ol class="section"><li><a href="7_1_the_main_loop.html"><strong aria-hidden="true">7.1.</strong> Running our runtime - the main loop</a></li><li><a href="7_2_setting_up_runtime.html"><strong aria-hidden="true">7.2.</strong> Setting up our runtime</a></li><li><a href="7_3_timers.html"><strong aria-hidden="true">7.3.</strong> Timers</a></li><li><a href="7_4_callbacks.html"><strong aria-hidden="true">7.4.</strong> Callbacks</a></li><li><a href="7_5_threadpool.html"><strong aria-hidden="true">7.5.</strong> Threadpool</a></li><li><a href="7_6_io_eventqueue.html"><strong aria-hidden="true">7.6.</strong> I/O eventqueue</a></li><li><a href="7_8_cleaning_up.html"><strong aria-hidden="true">7.7.</strong> Cleaning up</a></li><li><a href="7_9_infrastructure.html"><strong aria-hidden="true">7.8.</strong> Infrastructure</a></li></ol></li><li><a href="8_0_modules.html"><strong aria-hidden="true">8.</strong> Modules</a></li><li><ol class="section"><li><a href="8_1_file_module.html"><strong aria-hidden="true">8.1.</strong> File module</a></li><li><a href="8_2_crypto_module.html"><strong aria-hidden="true">8.2.</strong> Crypto module</a></li><li><a href="8_3_http_module.html"><strong aria-hidden="true">8.3.</strong> Http module</a></li></ol></li><li><a href="9_putting_pieces_together.html"><strong aria-hidden="true">9.</strong> Putting the pieces together</a></li><li><a href="10_final_code.html"><strong aria-hidden="true">10.</strong> Final code</a></li><li><a href="11_shortcuts_and_improvements.html"><strong aria-hidden="true">11.</strong> Shortcuts and improvements</a></li><li class="affix"><a href="conclusion.html">Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Investigating Async Basics - Implementing the Node.js Eventloop in Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#communicating-with-the-operating-system" id="communicating-with-the-operating-system">Communicating with the operating system</a></h1>
<p>In this chapter I want to dive into:</p>
<ul>
<li>What is a System Call</li>
<li>Abstractions over syscalls</li>
<li>Challenges low level cross platform code</li>
</ul>
<h2><a class="header" href="#what-is-a-syscall" id="what-is-a-syscall">What is a syscall</a></h2>
<p>Communication with the operating system is done through <code>System Calls</code> or 
&quot;syscalls&quot;. This is a public API that the operating system provides and that programs
can use to communicate with the OS. Most of the time these calls are abstracted away for us as 
programmers by the language or the runtime we use. A language like Rust makes it 
trivial to make a syscall though which we'll see below.</p>
<p>Now syscalls is an example of something that is unique to the kernel you're communicating with, but the UNIX family of kernels has many similarities especially the API exposed by <code>libc</code>.</p>
<p>Windows on the other hand  uses it's own api, often referred to as WinAPI, and that can be radically different from how the UNIX based systems operate. Most often though there is a way to achieve the same things. In terms of functionality you might not notice a big difference but as we'll see below and especially when we dig into how <code>epoll</code>, <code>kqueue</code> and <code>IOCP</code>, they can differ a lot on how this functionality is implemented.</p>
<h2><a class="header" href="#syscall-example" id="syscall-example">Syscall example</a></h2>
<p>To get a bit more familiar with syscalls we'll implement a very basic one for 
the three arcitectures: BSD(macos), Linux and Windows. We'll also see how this is implemented in three levels of abstractions.</p>
<p>The syscall we'll implement is the one used when we write something to <code>stdout</code> since that is such a common operation it's interesting to se how it really works.</p>
<h3><a class="header" href="#the-lowest-level-of-abstraction" id="the-lowest-level-of-abstraction">The lowest level of abstraction</a></h3>
<p>For this to work we need to write some inline assembly again. I'll skip the main function since that should be easy to understand now, and focus on the instructions we write to the CPU.</p>
<blockquote>
<p>If you want a more torough introduction to inline assembly I can refer you to the <a href="https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/an-example-we-can-build-upon">relevant chapter in my previous book</a> if you haven't read it already.</p>
</blockquote>
<p>Now at this level of abstraction, we'll write different code for all three platforms.</p>
<p>On both Linux and Macos the syscall we want to invole is called <code>write</code>. Both systems operates based on the concept of <code>file descriptors</code> and <code>stdout</code> is one of these alredy present when you start a proccess.</p>
<p><strong>On Linux a <code>write</code> syscall can look like this</strong></p>
<blockquote>
<p>If you want a more torough introduction to inline assembly I can refer you to the <a href="https://cfsamson.gitbook.io/green-threads-explained-in-200-lines-of-rust/an-example-we-can-build-upon">relevant chapter in my previous book</a> if you haven't read it already.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">#![feature(asm)]
fn main() {
    let message = String::from(&quot;Hello world from interrupt!\n&quot;);
    syscall(message);
}

#[cfg(target_os = &quot;linux&quot;)]
fn syscall(message: String) {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    unsafe {
        asm!(&quot;
        mov     $$1, %rax   # system call 1 is write on linux
        mov     $$1, %rdi   # file handle 1 is stdout
        mov     $0, %rsi    # address of string to output
        mov     $1, %rdx    # number of bytes
        syscall             # call kernel, syscall interrupt
    &quot;
        :
        : &quot;r&quot;(msg_ptr), &quot;r&quot;(len)

        )
    }
}
</code></pre></pre>
<p>The code to initiate the <code>write</code> syscall on Linux is <code>1</code> so when we write <code>$$1</code> we're writing the literal value 1 to the <code>rax</code> register.</p>
<blockquote>
<p><code>$$</code> in inline assembly using the AT&amp;T syntax is how you write a literal value. A single <code>$</code> means you're referring to parameter so when we write <code>$0</code> we're referring to the first parameter <code>msg_ptr</code>.</p>
</blockquote>
<p>Coincidentally, placing the value <code>1</code> in to the <code>rdi</code> register means that we're referring to <code>stdout</code> which is the file descriptor we want to write to. This has nothing to do with the fact that the <code>write</code> syscall also has the code <code>1</code>.</p>
<p>Secondly we pass in the address of our string buffer and the length of the buffer in the registers <code>rsi</code> and <code>rdx</code> respectively, and call the <code>syscall</code> instruction.</p>
<blockquote>
<p>The <code>syscall</code> is a rather new one. On the earlier 32-bit systems in the <code>x86</code> arcitecture, you invoked a syscall by issuing a software interrupt <code>int 0x80</code>. A software interrupt is considered slow at the level we're working at here so later it was added a seperate instruction for it called <code>syscall</code>. he <code>syscall</code> instruction uses <a href="http://articles.manugarg.com/systemcallinlinux2_6.html">VDSO</a> which is a memory page attached to each process so no context switch is necessary to execute the system call.</p>
</blockquote>
<p>On Macos, the syscall will look something like this:</p>
<pre><pre class="playpen"><code class="language-rust">#![feature(asm)]
fn main() {
    let message = String::from(&quot;Hello world from interrupt!\n&quot;);
    syscall(message);
}

#[cfg(target_os = &quot;macos&quot;)]
fn syscall(message: String) {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    unsafe {
        asm!(
            &quot;
        mov     $$0x2000004, %rax   # system call 0x2000004 is write on macos
        mov     $$1, %rdi           # file handle 1 is stdout
        mov     $0, %rsi            # address of string to output
        mov     $1, %rdx            # number of bytes
        syscall                     # call kernel, syscall interrupt
    &quot;
        :
        : &quot;r&quot;(msg_ptr), &quot;r&quot;(len)
        )
    };
}
</code></pre></pre>
<p>As you see this is not that different from the one we wrote for Linux, with the exception of the fact that syscall <code>write</code> has the code <code>0x2000004</code> instead of <code>1</code>.</p>
<p><strong>What about Windows?</strong></p>
<p>It's a good opportunity to explain why writing code like we do above is a bad idea. You see, if you want your code to work for a long time you have to worry about what <code>guarantees</code> the OS gives you. As far as I know, there are no guarantees that <code>$$0x2000004</code> on Macos will always refer to <code>write</code>. I do think Linux has better guarantees, but I know for a fact that Windows makes absolutely zero guarantees about this.</p>
<p>Windows has changed it's internals about this numerous times and provide no official documentation. The only thing we got is reverse engineered tables like <a href="https://j00ru.vexillium.org/syscalls/nt/64/">this</a>. That means that what was <code>write</code> can be changed to <code>delete</code> the next time you update Windows.</p>
<p>Even though it would be fun, as a curiosity, to include it I haven't managed to get it to work and have no idea how much code that would be. See <a href="./introduction.html">contributing</a> if you have the answer dear reader, and I'll include it if it's not too much code.</p>
<h2><a class="header" href="#the-next-level-of-abstraction" id="the-next-level-of-abstraction">The next level of abstraction</a></h2>
<p>The next level of abstraction is to use the API which all three operating systems provide for us. Already we can see that this abstraction helps us remove some code since fortunately for us in this specific example, the syscall is the same on Linux and on Macos so we only need to worry if we're on Windows and therefore use the <code>#[cfg(not(target_os = &quot;windows&quot;))]</code> conditional compilation flag. For the Windows syscall we do the opposite.</p>
<h3><a class="header" href="#using-the-api-in-linux-and-macos" id="using-the-api-in-linux-and-macos">Using the API in Linux and Macos</a></h3>
<p>You can run this code directly here in the window. However, the Rust playground 
runs on Linux, you'll need to copy the code over to a Windows machine if you 
want to try it out the code for Windows further down.</p>
<pre><pre class="playpen"><code class="language-rust">use std::io;

fn main() {
    let sys_message = String::from(&quot;Hello world from syscall!\n&quot;);
    syscall(sys_message).unwrap();
}

// and: http://man7.org/linux/man-pages/man2/write.2.html
#[cfg(not(target_os = &quot;windows&quot;))]
#[link(name = &quot;c&quot;)]
extern &quot;C&quot; {
    fn write(fd: u32, buf: *const u8, count: usize) -&gt; i32;
}

#[cfg(not(target_os = &quot;windows&quot;))]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    let res = unsafe { write(1, msg_ptr, len) };

    if res == -1 {
        return Err(io::Error::last_os_error());
    }
    Ok(())
}

</code></pre></pre>
<p>I'll explain what we just did here. I assume that the <code>main</code> method needs no 
comment.</p>
<pre><code class="language-rust no_run noplaypen">#[link(name = &quot;c&quot;)]
</code></pre>
<p>Every Linux installation comes with a version of <code>libc</code> which a C-library for 
communicating with the operating system. Having a <code>libc</code> with a consistent API 
means they can change the underlying implementation without braking everyones 
code. This flag tells the compiler to link to the &quot;c&quot; library on the system we'
re compiling for.</p>
<pre><code class="language-rust no_run noplaypen">extern &quot;C&quot; {
    fn write(fd: u32, buf: *const u8, count: usize);
}
</code></pre>
<p><code>extern &quot;C&quot;</code> or only <code>extern</code> (C is assumed if nothing is specified) means we're 
linking to specific functions in the &quot;c&quot; library using the &quot;C&quot; calling 
convention. As you'll see on Windows we'll need to change this since it uses a 
different calling convention than the UNIX family.</p>
<p>The function we're linking to needs to have the exact same name, in this case 
<code>write</code>. The parameters doesn't need to have the same name but they must be in 
the right order and it's good practice to name them the same as in the library 
you're linking to.</p>
<p>The write function takes a <code>file descriptor</code> which in this case is a handle to 
<code>stdout</code>, a pointer to a array of <code>u8</code> values, and a count of how many values we 
want to read from the buffer.</p>
<pre><code class="language-rust no_run noplaypen">#[cfg(not(target_os = &quot;windows&quot;))]
fn syscall_libc(message: String) {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    unsafe { write(1, msg_ptr, len) };
}
</code></pre>
<p>The first thing we do is to get the pointer to the underlying buffer for our 
string. That will be a pointer of type <code>*const u8</code> which matches our <code>buf</code> 
argument. The length of the message corresponds to the <code>count</code> argument.</p>
<p>You might ask how we know that <code>1</code> is the file handle to <code>stdout</code> and where we 
found that value. You'll notice this a lot when writing syscalls from Rust. 
Usually constants are defined in the C header files which we can't link to, so 
we need to search them up. 1 is always the file descriptor for <code>stdout</code> on UNIX 
systems.</p>
<p>A call to a FFI function is always unsafe so we need to use the <code>unsafe</code> keyword 
here.</p>
<h3><a class="header" href="#using-the-api-on-windows" id="using-the-api-on-windows">Using the API on Windows</a></h3>
<pre><code class="language-rust no_run noplaypen">use std::io;

fn main() {
    let sys_message = String::from(&quot;Hello world from syscall!\n&quot;);
    syscall(sys_message).unwrap();
}

#[cfg(target_os = &quot;windows&quot;)]
#[link(name = &quot;kernel32&quot;)]
extern &quot;stdcall&quot; {
    /// https://docs.microsoft.com/en-us/windows/console/getstdhandle
    fn GetStdHandle(nStdHandle: i32) -&gt; i32;
    /// https://docs.microsoft.com/en-us/windows/console/writeconsole
    fn WriteConsoleW(
        hConsoleOutput: i32,
        lpBuffer: *const u16,
        numberOfCharsToWrite: u32,
        lpNumberOfCharsWritten: *mut u32,
        lpReserved: *const std::ffi::c_void,
    ) -&gt; i32;
}

#[cfg(target_os = &quot;windows&quot;)]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {

    // let's convert our utf-8 to a format windows understands
    let msg: Vec&lt;u16&gt; = message.encode_utf16().collect();
    let msg_ptr = msg.as_ptr();
    let len = msg.len() as u32;
    
    let mut output: u32 = 0;
        let handle = unsafe { GetStdHandle(-11) };
        if handle  == -1 {
            return Err(io::Error::last_os_error())
        }

        let res = unsafe { 
            WriteConsoleW(handle, msg_ptr, len, &amp;mut output, std::ptr::null()) 
            };
        if res  == 0 {
            return Err(io::Error::last_os_error());
        }

    assert_eq!(output as usize, len);
    Ok(())
}
</code></pre>
<pre><code>The Rust playground, which we use to run our code, is a Linux machine. I 
disabled the possibility to run the windows code here (since it will 
essentially just be skipped on compilation). However, if you have a Windows 
machine, copy the code above and try for yourself.
</code></pre>
<p>Now, just by looking at the code above you see it starts to get a bit more 
complex, but let's spend som time to go through line by line what we do here as 
well.</p>
<pre><code class="language-text">#[cfg(target_os = &quot;windows&quot;)]
#[link(name = &quot;kernel32&quot;)]
</code></pre>
<p>The first line is just telling the compiler to only compile this if the 
<code>target_os</code> is Windows.</p>
<p>The second line is a linker directive, telling the linker we want to link to the 
library <code>kernel32</code> (if you ever see an example that links to <code>user32</code> that will 
also work).</p>
<pre><code class="language-rust no_run noplaypen">extern &quot;stdcall&quot; {
    /// https://docs.microsoft.com/en-us/windows/console/getstdhandle
    fn GetStdHandle(nStdHandle: i32) -&gt; i32;
    /// https://docs.microsoft.com/en-us/windows/console/writeconsole
    fn WriteConsoleW(
        hConsoleOutput: i32,
        lpBuffer: *const u16,
        numberOfCharsToWrite: u32,
        lpNumberOfCharsWritten: *mut u32,
        lpReserved: *const std::ffi::c_void,
    ) -&gt; i32;
}
</code></pre>
<p>First of all, <code>extern &quot;stdcall&quot;</code>, tells the compiler that we won't use the <code>C</code> 
calling convention but use Windows calling convention called <code>stdcall</code>.</p>
<p>The next part is the functions we want to link to. On Windows, we need to link 
to two functions to get this to work: <code>GetStdHandle</code> and <code>WriteConsoleA</code>. 
<code>GetStdHandle</code> retrieves a reference to a standard device like <code>stdout</code>.</p>
<p>WriteConsole comes in two flavors, <code>WriteConsoleW</code> that takes in Unicode text 
and <code>WriteConsoleA</code> that takes ANSI encoded text. </p>
<p>Now, ANSI encoded text works fine if you only write English text, but as soon as 
you write text in other languages you might need to use special characters that 
are not possible to represent in <code>ANSI</code> but is possible in <code>utf-8</code> and our code 
will break.</p>
<p>That's why we'll convert our <code>utf-8</code> encoded text to <code>utf-16</code> encoded Unicode 
text that can represent these characters and use the <code>WriteConsoleW</code> function.</p>
<pre><code class="language-rust no_run noplaypen">#[cfg(target_os = &quot;windows&quot;)]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {

    // let's convert our utf-8 to a format windows understands
    let msg: Vec&lt;u16&gt; = message.encode_utf16().collect();
    let msg_ptr = msg.as_ptr();
    let len = msg.len() as u32;
    
    let mut output: u32 = 0;
        let handle = unsafe { GetStdHandle(-11) };
        if handle  == -1 {
            return Err(io::Error::last_os_error())
        }

        let res = unsafe { 
            WriteConsoleW(handle, msg_ptr, len, &amp;mut output, std::ptr::null()) 
            };

        if res  == 0 {
            return Err(io::Error::last_os_error());
        }

    assert_eq!(output, len);
    Ok(())
}
</code></pre>
<p>The first thing we do is to convert the text to utf-16 encoded text which 
Windows uses. Fortunately Rust has a built in function to encode our <code>utf-8</code>
encoded text to <code>utf-16</code> code points. <code>encode_utf16</code> returns an iterator over 
<code>u16</code> code points that we can collect to a <code>Vec</code>.</p>
<pre><code class="language-rust no_run noplaypen">let msg: Vec&lt;u16&gt; = message.encode_utf16().collect();
let msg_ptr = msg.as_ptr();
let len = msg.len() as u32;
</code></pre>
<p>We then get the pointer to the underlaying buffer of our <code>Vec</code> and calculate the 
length.</p>
<pre><code class="language-rust no_run noplaypen">let handle = unsafe { GetStdHandle(-11) };
   if handle  == -1 {
       return Err(io::Error::last_os_error())
   }
</code></pre>
<p>The next is a call to <code>GetStdHandle</code>. We pass in the value <code>-11</code>. The values we 
need to pass in for the different standard devices is actually documented 
together with the <code>GetStdHandle</code> documentation:</p>
<ul>
<li>Stdin: -10</li>
<li>Stdout: -11</li>
<li>StdErr: -12</li>
</ul>
<p>Now, we're lucky here, it's not that common that we find this information 
together with the documentation function we call but it's very convenient when 
we do.</p>
<p>What return codes to expect is also documented thoroughly so we handle potential 
errors here in the same way as we did for the Linux/Macos syscalls.</p>
<pre><code class="language-rust no_run noplaypen">let res = unsafe { 
    WriteConsoleW(handle, msg_ptr, len, &amp;mut output, std::ptr::null()) 
    };

if res  == 0 {
    return Err(io::Error::last_os_error());
}
</code></pre>
<p>Next up is the call to the <code>WriteConsoleW</code> function. Now that we have explained 
everything else there is nothing too fancy about this.</p>
<h2><a class="header" href="#the-highest-level-of-abstraction" id="the-highest-level-of-abstraction">The highest level of abstraction</a></h2>
<p>This is simple, most standard libraies provide this abstraction for you. In rust that would simple be:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
println!(&quot;Hello world from Stdlib&quot;);
#}</code></pre></pre>
<h2><a class="header" href="#a-note-about-complexity" id="a-note-about-complexity">A note about complexity</a></h2>
<p>There is a lot of &quot;hidden&quot; complexity when writing cross platform code at this 
level. One hurdle is to get something working, which can prove to be quite a 
challenge. Getting it to work <strong>correctly</strong> and <strong>safely</strong> while covering edge 
cases is an additional challenge. </p>
<p>Are we 100% sure that all valid <code>utf-8</code> code points which we use in Rust is valid 
<code>utf-16</code> encoded Unicode that Windows will display correctly?</p>
<p>I think so, but being 100 % sure about <a href="https://en.wikipedia.org/wiki/Comparison_of_Unicode_encodings">this might not be as easy as one might think</a>.</p>
<h1><a class="header" href="#our-finished-cross-platform-syscall" id="our-finished-cross-platform-syscall">Our finished cross platform syscall</a></h1>
<pre><pre class="playpen"><code class="language-rust">use std::io;

fn main() {
    let sys_message = String::from(&quot;Hello world from syscall!\n&quot;);
    syscall(sys_message).unwrap();
}

// and: http://man7.org/linux/man-pages/man2/write.2.html
#[cfg(not(target_os = &quot;windows&quot;))]
#[link(name = &quot;c&quot;)]
extern &quot;C&quot; {
    fn write(fd: u32, buf: *const u8, count: usize) -&gt; i32;
}

#[cfg(not(target_os = &quot;windows&quot;))]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {
    let msg_ptr = message.as_ptr();
    let len = message.len();
    let res = unsafe { write(1, msg_ptr, len) };

    if res == -1 {
        return Err(io::Error::last_os_error());
    }
    Ok(())
}

#[cfg(target_os = &quot;windows&quot;)]
#[link(name = &quot;kernel32&quot;)]
extern &quot;stdcall&quot; {
    /// https://docs.microsoft.com/en-us/windows/console/getstdhandle
    fn GetStdHandle(nStdHandle: i32) -&gt; i32;
    /// https://docs.microsoft.com/en-us/windows/console/writeconsole
    fn WriteConsoleW(
        hConsoleOutput: i32,
        lpBuffer: *const u16,
        numberOfCharsToWrite: u32,
        lpNumberOfCharsWritten: *mut u32,
        lpReserved: *const std::ffi::c_void,
    ) -&gt; i32;
}

#[cfg(target_os = &quot;windows&quot;)]
fn syscall(message: String) -&gt; io::Result&lt;()&gt; {

    // let's convert our utf-8 to a format windows understands
    let msg: Vec&lt;u16&gt; = message.encode_utf16().collect();
    let msg_ptr = msg.as_ptr();
    let len = msg.len() as u32;

    let mut output: u32 = 0;
        let handle = unsafe { GetStdHandle(-11) };
        if handle  == -1 {
            return Err(io::Error::last_os_error())
        }

        let res = unsafe { 
            WriteConsoleW(handle, msg_ptr, len, &amp;mut output, std::ptr::null()) 
            };

        if res  == 0 {
            return Err(io::Error::last_os_error());
        }

    assert_eq!(output, len);
    Ok(())
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="3_0_the_operating_system.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="3_2_cross_platform_abstractions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="3_0_the_operating_system.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="3_2_cross_platform_abstractions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
