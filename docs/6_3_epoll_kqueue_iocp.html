<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Epoll, Kqueue and IOCP - Investigating Async Basics - Implementing the Node.js Eventloop in Rust</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="1_concurrent_vs_parallel.html"><strong aria-hidden="true">1.</strong> Concurrent vs Parallel</a></li><li><a href="2_async_history.html"><strong aria-hidden="true">2.</strong> Async history</a></li><li><a href="3_0_the_operating_system.html"><strong aria-hidden="true">3.</strong> The Operating System and CPU</a></li><li><ol class="section"><li><a href="3_1_communicating_with_the_os.html"><strong aria-hidden="true">3.1.</strong> Communicating with the OS</a></li><li><a href="3_2_cross_platform_abstractions.html"><strong aria-hidden="true">3.2.</strong> Writing Cross Platform Abstractions</a></li><li><a href="3_3_the_cpu_and_the_os.html"><strong aria-hidden="true">3.3.</strong> The CPU and the OS</a></li></ol></li><li><a href="4_interrupts_firmware_io.html"><strong aria-hidden="true">4.</strong> Interrupts, Firmware and I/O</a></li><li><a href="5_strategies_for_handling_io.html"><strong aria-hidden="true">5.</strong> Strategies for handling I/O</a></li><li><a href="6_0_implementing_the_node_eventloop.html"><strong aria-hidden="true">6.</strong> Implementing our &quot;Node&quot; Eventloop</a></li><li><ol class="section"><li><a href="6_1_what_is_node.html"><strong aria-hidden="true">6.1.</strong> What is Node?</a></li><li><a href="6_2_whats_our_plan.html"><strong aria-hidden="true">6.2.</strong> What's our plan</a></li><li><a href="6_3_epoll_kqueue_iocp.html" class="active"><strong aria-hidden="true">6.3.</strong> Epoll, Kqueue and IOCP</a></li></ol></li><li><a href="7_0_the_runtime.html"><strong aria-hidden="true">7.</strong> The runtime</a></li><li><ol class="section"><li><a href="7_1_the_main_loop.html"><strong aria-hidden="true">7.1.</strong> Running our runtime - the main loop</a></li><li><a href="7_2_setting_up_runtime.html"><strong aria-hidden="true">7.2.</strong> Setting up our runtime</a></li><li><a href="7_3_timers.html"><strong aria-hidden="true">7.3.</strong> Timers</a></li><li><a href="7_4_callbacks.html"><strong aria-hidden="true">7.4.</strong> Callbacks</a></li><li><a href="7_5_threadpool.html"><strong aria-hidden="true">7.5.</strong> Threadpool</a></li><li><a href="7_6_io_eventqueue.html"><strong aria-hidden="true">7.6.</strong> I/O eventqueue</a></li><li><a href="7_8_cleaning_up.html"><strong aria-hidden="true">7.7.</strong> Cleaning up</a></li><li><a href="7_9_infrastructure.html"><strong aria-hidden="true">7.8.</strong> Infrastructure</a></li></ol></li><li><a href="8_0_modules.html"><strong aria-hidden="true">8.</strong> Modules</a></li><li><ol class="section"><li><a href="8_1_file_module.html"><strong aria-hidden="true">8.1.</strong> File module</a></li><li><a href="8_2_crypto_module.html"><strong aria-hidden="true">8.2.</strong> Crypto module</a></li><li><a href="8_3_http_module.html"><strong aria-hidden="true">8.3.</strong> Http module</a></li></ol></li><li><a href="9_putting_pieces_together.html"><strong aria-hidden="true">9.</strong> Putting the pieces together</a></li><li><a href="10_final_code.html"><strong aria-hidden="true">10.</strong> Final code</a></li><li><a href="11_shortcuts_and_improvements.html"><strong aria-hidden="true">11.</strong> Shortcuts and improvements</a></li><li class="affix"><a href="conclusion.html">Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Investigating Async Basics - Implementing the Node.js Eventloop in Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#epoll-kqueue-and-iocp" id="epoll-kqueue-and-iocp">Epoll, kqueue and IOCP</a></h1>
<p>Part of Nodes runtime is <a href="https://github.com/libuv/libuv">libuv</a> which is a cross platform
asynchronous I/O library. <code>libuv</code> is not only used in Node but also forms the foundation
of how <a href="https://julialang.org/">Julia</a> and <a href="https://github.com/saghul/pyuv">Pyuv</a>. Most
languages has bindings for it. </p>
<p>In Rust we have <a href="https://github.com/tokio-rs/mio">mio - Metal IO</a>. Since we want
to understand how everything works from the bottom, I had to create an extremely
simplified version of such a library. I called it <code>minimio</code> for obvious reasons.</p>
<blockquote>
<p>I will write a short book (much shorter than this one) about how this works in
detail, for now you can visit the code in the it's <a href="https://github.com/cfsamson/examples-minimio">Github repository if you're
curious</a>. This book will also cover
<code>wepoll</code> which is used as an optimization instead of IOCP in both <code>mio</code> and <code>libuv</code>. </p>
</blockquote>
<p>However, we'll give each of them a brief introduction here so you know what we're
working with.</p>
<h2><a class="header" href="#why-and-os-backed-event-queue" id="why-and-os-backed-event-queue">Why and OS backed event queue</a></h2>
<p>If you remember my previous chapters you know that we need to cooperate closely
with the OS to make I/O operations as efficient as possible. Operating systems like
Linux, Macos and Windows provides several ways of performing I/O, both blocking and
non-blocking.</p>
<p>As you probably have understood, blocking means only to us, but we yield control over
our thread to the OS. So blocking operations are the least flexible to use for us
as programmers.</p>
<p>Non-blocking metods needs a way to communicate their state to you so you can
tell if they're ready or not, but instead of you asking for a status every now
and then there are better ways.</p>
<blockquote>
<p>We'll not cover methods like <code>poll</code> and <code>select</code> but I have an <a href="https://people.eecs.berkeley.edu/%7Esangjin/2012/12/21/epoll-vs-kqueue.html">article for you
here</a>
if you want to learn a bit about these methods and how they differ from <code>epoll</code>.</p>
</blockquote>
<h2><a class="header" href="#readiness-based-event-queue" id="readiness-based-event-queue">Readiness based event queue</a></h2>
<p>Epoll and Kqueue are what we call readiness based event queues. They're called
that since they let you know when an action is ready to be performed. For example
when a socket is ready to be read from.</p>
<p>Basically this happens when we want to read data from a socket:</p>
<ol>
<li>We create an event queue by calling the syscall <code>epoll_create</code> or <code>kqueue</code></li>
<li>We create a file descriptor representing a socket</li>
<li>We register an interest in <code>Read</code> events on this socket with a second syscall</li>
<li>Next, we call, <code>epoll_wait</code> or <code>kevent</code> to wait for an event - this will block</li>
<li>When the event is ready, our thread is unblocked and we return from one of our
&quot;wait&quot; methods with data about what event occurred.</li>
<li>We call <code>read</code> on the socket we created in 2.</li>
</ol>
<h2><a class="header" href="#completion-based-event-queue" id="completion-based-event-queue">Completion based event queue</a></h2>
<p>IOCP stands for I/O Completion Ports, and in this type of queue you get a
notification when events are completed. For example data is read to a buffer.</p>
<p>This is the basics of what happens in an even queue:</p>
<ol>
<li>We create an event queue by calling the syscall <code>CreateIoCompletionPort</code></li>
<li>We create a buffer and a get a handle to a socket</li>
<li>We register an interest in <code>Read</code> events on this socket with another syscall,
but this time we also pass inn the buffer we created to which the data will
be read.</li>
<li>Next, we call <code>GetQueuedCompletionStatusEx</code> which will block until an event has
completed</li>
<li>Our thread is unblocked and our buffer is filled with the data we're interested in</li>
</ol>
<h2><a class="header" href="#epoll" id="epoll">Epoll</a></h2>
<p><code>Epoll</code> is the Linux way of implementing an event queue. In terms of functionality it has a lot of 
common with <code>Kqueue</code>. On a high level these abstractions provide us with this functionality:</p>
<ol>
<li>A handle to an event queue</li>
<li>A way for us to register interest for events on a file descriptor and place it in this queue</li>
<li>A way for us to wait for this event to occur by letting the OS suspend our thread and wake us up when event is ready</li>
</ol>
<h3><a class="header" href="#kqueue" id="kqueue">Kqueue</a></h3>
<p><code>Kqueue</code> is the Macos way of implementing an event queue, well, actually it's 
the BSD way of doing this that Macos uses. In terms of high level functionality
it's similar to <code>Epoll</code> in concept but different to use.</p>
<p>Some argue it's a bit more complex to use and a bit more abstract and &quot;general&quot;.</p>
<h3><a class="header" href="#iocp" id="iocp">IOCP</a></h3>
<p><code>IOCP</code> or Input Output Completion Ports is the way Windows handles this type of event queue. </p>
<p>This means it will let you know when an event has <code>Completed</code>. Now this might
sound like a minor difference but it's not, especially when you want to write a
library since abstracting over both means you'll either have to model <code>IOCP</code> as
<code>readiness based</code> or model <code>epoll/kqueue</code> as completion based.</p>
<p>Lending out a buffer to the OS also provides some challenges since it's very
important that this buffer stays untouched while waiting for an operation to
return.</p>
<blockquote>
<p>My experience investigating this suggests that getting the <code>readiness based</code>
models to behave like the <code>completion based</code> model is easier than the other
way around. This means get IOCP to work first and then fit <code>epoll</code> and <code>kqueue</code>
into that design. I'm open to other views as well.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="6_2_whats_our_plan.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="7_0_the_runtime.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="6_2_whats_our_plan.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="7_0_the_runtime.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
