<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Running our runtime - the main loop - Investigating Async Basics - Implementing the Node.js Eventloop in Rust</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="introduction.html">Introduction</a></li><li><a href="1_concurrent_vs_parallel.html"><strong aria-hidden="true">1.</strong> Concurrent vs Parallel</a></li><li><a href="2_async_history.html"><strong aria-hidden="true">2.</strong> Async history</a></li><li><a href="3_0_the_operating_system.html"><strong aria-hidden="true">3.</strong> The Operating System and CPU</a></li><li><ol class="section"><li><a href="3_1_communicating_with_the_os.html"><strong aria-hidden="true">3.1.</strong> Communicating with the OS</a></li><li><a href="3_2_cross_platform_abstractions.html"><strong aria-hidden="true">3.2.</strong> Writing Cross Platform Abstractions</a></li><li><a href="3_3_the_cpu_and_the_os.html"><strong aria-hidden="true">3.3.</strong> The CPU and the OS</a></li></ol></li><li><a href="4_interrupts_firmware_io.html"><strong aria-hidden="true">4.</strong> Interrupts, Firmware and I/O</a></li><li><a href="5_strategies_for_handling_io.html"><strong aria-hidden="true">5.</strong> Strategies for handling I/O</a></li><li><a href="6_0_implementing_the_node_eventloop.html"><strong aria-hidden="true">6.</strong> Implementing our &quot;Node&quot; Eventloop</a></li><li><ol class="section"><li><a href="6_1_what_is_node.html"><strong aria-hidden="true">6.1.</strong> What is Node?</a></li><li><a href="6_2_whats_our_plan.html"><strong aria-hidden="true">6.2.</strong> What's our plan</a></li><li><a href="6_3_epoll_kqueue_iocp.html"><strong aria-hidden="true">6.3.</strong> Epoll, Kqueue and IOCP</a></li></ol></li><li><a href="7_0_the_runtime.html"><strong aria-hidden="true">7.</strong> The runtime</a></li><li><ol class="section"><li><a href="7_1_the_main_loop.html" class="active"><strong aria-hidden="true">7.1.</strong> Running our runtime - the main loop</a></li><li><a href="7_2_setting_up_runtime.html"><strong aria-hidden="true">7.2.</strong> Setting up our runtime</a></li><li><a href="7_3_timers.html"><strong aria-hidden="true">7.3.</strong> Timers</a></li><li><a href="7_4_callbacks.html"><strong aria-hidden="true">7.4.</strong> Callbacks</a></li><li><a href="7_5_threadpool.html"><strong aria-hidden="true">7.5.</strong> Threadpool</a></li><li><a href="7_6_io_eventqueue.html"><strong aria-hidden="true">7.6.</strong> I/O eventqueue</a></li><li><a href="7_8_cleaning_up.html"><strong aria-hidden="true">7.7.</strong> Cleaning up</a></li><li><a href="7_9_infrastructure.html"><strong aria-hidden="true">7.8.</strong> Infrastructure</a></li></ol></li><li><a href="8_0_modules.html"><strong aria-hidden="true">8.</strong> Modules</a></li><li><ol class="section"><li><a href="8_1_file_module.html"><strong aria-hidden="true">8.1.</strong> File module</a></li><li><a href="8_2_crypto_module.html"><strong aria-hidden="true">8.2.</strong> Crypto module</a></li><li><a href="8_3_http_module.html"><strong aria-hidden="true">8.3.</strong> Http module</a></li></ol></li><li><a href="9_putting_pieces_together.html"><strong aria-hidden="true">9.</strong> Putting the pieces together</a></li><li><a href="10_final_code.html"><strong aria-hidden="true">10.</strong> Final code</a></li><li><a href="11_shortcuts_and_improvements.html"><strong aria-hidden="true">11.</strong> Shortcuts and improvements</a></li><li class="affix"><a href="conclusion.html">Conclusion</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Investigating Async Basics - Implementing the Node.js Eventloop in Rust</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#the-main-loop" id="the-main-loop">The main loop</a></h1>
<p>Let's put our event loop logic in the <code>run</code> function of our <code>Runtime</code>. The code
which we present on this chapter is the body of this <code>run</code> function.</p>
<p>I'll include the whole method last so you can see it all together.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Runtime {
    fn run() {
        ...
    }
}
#}</code></pre></pre>
<h2><a class="header" href="#initialization" id="initialization">Initialization</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let rt_ptr: *mut Runtime = self;
unsafe { RUNTIME = rt_ptr as usize };
let mut timers_to_remove = vec![]; 
let mut ticks = 0; // just for us priting out

// First we run our &quot;main&quot; function
f();
#}</code></pre></pre>
<p>The first two lines is just a <code>hack</code> we use in our code to make it &quot;look&quot; more
like javascript. Here we take the pointer to <code>self</code> and set it in the global
variable <code>RUNTIME</code>. We could instead pass our <code>runtime</code> around but that wouldn't
be very ergonomic. Another option would be to use <code>lazy_static</code> crate to initlialize
this field in a safer way, but we'd have to explain what <code>lazy_static</code> do to keep
our promise of minimal &quot;magic&quot;. To be honest, we only set this once, and it's set at
the start of of our eventloop and not touched until it's finished so in this case we
could argue it's safe to do it like this.</p>
<p>The variable <code>timers_to_remove</code> is for us to keep track of the timers we've set.
<code>ticks</code> is only a counter for us to keep track of how many times we've looped
to display.</p>
<p>The first thing we do to kick of the code is invoking <code>f()</code>. <code>f</code> will be the
code we wrote in the <code>javascript</code> function in the last chapter. If this is empty
nothing will happen.</p>
<h2><a class="header" href="#starting-the-event-loop" id="starting-the-event-loop">Starting the event loop</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ===== EVENT LOOP =====
while self.pending_events &gt; 0 {
    ticks += 1;
#}</code></pre></pre>
<p>There are two things to note here:</p>
<p><code>self.pending_events</code> isn't in our runtime struct yet so we need to add that. 
This variable keeps track of how many pending events we have, so that when no 
events are left we exit the loop since our eventloop is finished.</p>
<p>So where does these events come from? In our <code>javascript</code> function in the 
previous chapters you probably noticed that we called functions like 
<code>set_timeout</code> and <code>Fs::read</code>. These functions are defined in the Node runtime 
(as they are in ours), and they don't do much except from regestering events. 
So when one of these events are registered this counter is increased.</p>
<p><code>ticks</code> is just increasing a <code>tick</code> in the counter.</p>
<p>So our Runtime struct looks like this now:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Runtime {
    pending_events: usize,
}
#}</code></pre></pre>
<h2><a class="header" href="#1-effectuate-timers" id="1-effectuate-timers">1. Effectuate timers</a></h2>
<p><code>self.effectuate_timers(&amp;mut timers_to_remove);</code></p>
<p>We check here if any timers has expired. I couldn't find a better word for it
than <code>effectuate</code> but it basically mean that if we have timers that are expired
we schedule the callbacks for the expired timers to run at the first call to <code>self.run_callbacks()</code>.</p>
<p>Worth noting here is that timers with a timeout of <code>0</code> will already have timed
out by the time we reach this function.</p>
<h2><a class="header" href="#2-callbacks" id="2-callbacks">2. Callbacks</a></h2>
<p><code>self.run_callbacks();</code></p>
<p>Now we could have ran the callbacks in the timer <code>step</code> but since this is the next
step of our loop we do it here instead.</p>
<blockquote>
<p>This step might seem unnecessary here but in Node it has a function. Some
types of callbacks will be deferred to the <code>next tick</code>, which means that they're
not run immediately, but deferred to this step on the next loop. We won't implement
this functionality here but it's worth noting.</p>
</blockquote>
<h2><a class="header" href="#3-idleprepare" id="3-idleprepare">3. Idle/Prepare</a></h2>
<p>This is a step mostly used by Nodes internals. It's not important for understanding
the big picture here but I included it since it's something you see in Nodes
documentation so you know where we're at in the loop at this point.</p>
<h2><a class="header" href="#4-poll" id="4-poll">4. Poll</a></h2>
<p>This is really where everything happens. I refer to the <code>epoll/kqueue/IOCP</code> 
eventqueue as <code>epoll</code> here just so you know that it's not only <code>epoll</code> we're
waiting for. From now on I will refer to the cross platform event queue as <code>epoll</code>
in the code.</p>
<p>First we check if the OS has reported any events, and if so we schedule the
corresponding callbacks to run.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
self.process_epoll_events();
#}</code></pre></pre>
<p>Next we check if our threadpool has finished any work and if so we schedule their
corresponding callbacks to be run too:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
self.process_threadpool_events();
#}</code></pre></pre>
<p>If our <code>epoll</code> queue or our <code>threadpool</code> registered any callbacks we run them now.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
self.run_callbacks();
#}</code></pre></pre>
<blockquote>
<p>There are some important differences between our implementation and Nodes here.</p>
<p>We only check if any events are registered here and then continue on. This is
suboptimal since if we're wasting cycles by looping when there might be nothing
to do on the next iteration. </p>
<p>Node solves this by calculating the time until the next timeout (in step 1) 
times out. Let's say that the next timer times out in 10 seconds. In node 10 
seconds is then passed as a timeout for the <code>polls</code> in our poll phase so even 
though no event has happened it will wake up again and iterate so it executes 
the next timer when it starts the loop again. As you understand, that means
that the timer will not run at the exact same time as it times out, but it's
potentially much more efficient than what we do here.</p>
</blockquote>
<h2><a class="header" href="#5-check" id="5-check">5. Check</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ===== CHECK =====
// an set immediate function could be added pretty easily but we won't that here
#}</code></pre></pre>
<p>Node implements a check &quot;hook&quot; to the eventloop next. Calls to <code>setImmidiate</code>
execute here. I just include it for for completeness but we won't do anything in this phase.</p>
<h2><a class="header" href="#6-close-callbacks" id="6-close-callbacks">6. Close Callbacks</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// ===== CLOSE CALLBACKS ======
// Release resources, we won't do that here, it's just another &quot;hook&quot; for our &quot;extensions&quot;
// to use. We release in every callback instead
#}</code></pre></pre>
<h2><a class="header" href="#7-give" id="7-give">7. Give</a></h2>
<p>I pretty much explain this step in the comments. Typically releasing resources,
like closing sockets, is done here.</p>
<h2><a class="header" href="#the-run-function" id="the-run-function">The <code>run</code> function</a></h2>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Runtime {
    pub fn run(&amp;mut self, f: impl Fn()) {
        let rt_ptr: *mut Runtime = self;
        unsafe { RUNTIME = rt_ptr as usize };
        let mut ticks = 0; // just for us priting out

        // First we run our &quot;main&quot; function
        f();

        // ===== EVENT LOOP =====
        while self.pending_events &gt; 0 {
            ticks += 1;

            // ===== 2. TIMERS =====
            self.process_expired_timers();

            // NOT PART OF LOOP, JUST FOR US TO SEE WHAT TICK IS EXCECUTING
            if !self.callbacks_to_run.is_empty() {
                print(format!(&quot;===== TICK {} =====&quot;, ticks));
            }

            // ===== 2. CALLBACKS =====
            // Timer callbacks and if for some reason we have postponed callbacks
            // to run on the next tick. Not possible in our implementation though.
            self.run_callbacks();

            // ===== 3. IDLE/PREPARE =====
            // we won't use this

            // ===== 4. POLL =====
            self.process_epoll_events();
            self.process_threadpool_events();
            self.run_callbacks();

            // ===== 5. CHECK =====
            // an set immidiate function could be added pretty easily but we 
            // won't do that here

            // ===== 6. CLOSE CALLBACKS ======
            // Release resources, we won't do that here, but this is typically
            // where sockets etc are closed.

            // Let the OS have a time slice of our thread so we don't busy loop
            // this could be dynamically set depending on requirements or load.
            thread::park_timeout(std::time::Duration::from_millis(1));
        }
        print(&quot;FINISHED&quot;);
    }
}
#}</code></pre></pre>
<h2><a class="header" href="#shortcuts" id="shortcuts">Shortcuts</a></h2>
<p>I'll mention some obvious shortcuts right here so you are aware of them. There are many &quot;exceptions&quot; that we don't cover in our example. We are focusing on the big picture just so we're on the same page. The <code>process.nextTick</code> function and the <code>setImmediate</code> function are two examples of this. I explained how we did skip the fact that the next timeout will define how long the <code>poll</code> phase will potentially block instead of continue the loop like we do here.</p>
<p>We don't cover the case where a server under heavy load might have too many callbacks to reasonably run in one <code>poll</code> which means that we could starve our I/O resources in the meantime waiting for them to finish, and probably several similar cases that a production
runtime should care about.</p>
<p>As you'll probably notice, implementing a simple version is more than enough work
for us to cover in this book, but hopefully you'll find yourself in pretty good
shape to dig further once we're finished.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="7_0_the_runtime.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="7_2_setting_up_runtime.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="7_0_the_runtime.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="7_2_setting_up_runtime.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
